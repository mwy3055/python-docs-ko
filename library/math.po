# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-30 09:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Woo-young Myung <mwy3055@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/math.rst:2
msgid ":mod:`math` --- Mathematical functions"
msgstr ":mod:'math' --- 수학 함수"

#: ../Doc/library/math.rst:13
msgid ""
"This module is always available.  It provides access to the mathematical "
"functions defined by the C standard."
msgstr ""
"이 모듈은 항상 사용할 수 있습니다. 이 모듈은 C 표준에 의해 정의된 "
"함수에 접근할 수 있게 해 줍니다."

#: ../Doc/library/math.rst:16
msgid ""
"These functions cannot be used with complex numbers; use the functions of"
" the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex"
" numbers and those which don't is made since most users do not want to "
"learn quite as much mathematics as required to understand complex "
"numbers.  Receiving an exception instead of a complex result allows "
"earlier detection of the unexpected complex number used as a parameter, "
"so that the programmer can determine how and why it was generated in the "
"first place."
msgstr ""
"복소수에 대해 이 함수를 사용하면 안 됩니다; 복소수에 대한 함수는 :mod:'cmath' "
"모듈에 같은 이름으로 정의되어 있습니다. 이러한 구분을 하는 이유는 대부분의 사용자들이 "
"복소수와 관련된 복잡한 수학을 배우고 싶어하지 않기 때문입니다. 매개변수로 복소수를 사용"
"했을 때 복소수 값 대신 예외를 반환함으로써, 프로그래머는 그것이 어떻게, 왜 발생했는지 "
"알 수 있게 됩니다."

#: ../Doc/library/math.rst:25
msgid ""
"The following functions are provided by this module.  Except when "
"explicitly noted otherwise, all return values are floats."
msgstr ""
"다음의 함수는 이 모듈에 의해 제공됩니다. 명시적으로 언급하지 않은 경우에는, "
"모든 반환값은 실수입니다."

#: ../Doc/library/math.rst:30
msgid "Number-theoretic and representation functions"
msgstr ""
"정수론과 표현에 관한 함수"

#: ../Doc/library/math.rst:34
msgid ""
"Return the ceiling of *x*, the smallest integer greater than or equal to "
"*x*. If *x* is not a float, delegates to ``x.__ceil__()``, which should "
"return an :class:`~numbers.Integral` value."
msgstr ""
"*x*\\의 천장 함수 값, 즉 *x*\\보다 크거나 같은 최소의 정수값을 반환합니다. *x*\\가 실수가 "
"아니라면, :class:`numbers.Integral` 을 반환하는 ``x.__ceil__()``\\을 대신 호출합니다."

#: ../Doc/library/math.rst:41
msgid ""
"Return a float with the magnitude (absolute value) of *x* but the sign of"
" *y*.  On platforms that support signed zeros, ``copysign(1.0, -0.0)`` "
"returns *-1.0*."
msgstr ""
"*y*\\와 부호가 같고 *x*\\의 절댓값을 갖는 실수값을 반환합니다. 부호 있는 0을 지원하는 "
"플랫폼에서는, ``copysign(1.0, -0.0)``\\은 *-1.0*\\을 반환합니다."

#: ../Doc/library/math.rst:48
msgid "Return the absolute value of *x*."
msgstr ""
"*x*\\의 절댓값을 반환합니다."

#: ../Doc/library/math.rst:53
msgid ""
"Return *x* factorial.  Raises :exc:`ValueError` if *x* is not integral or"
" is negative."
msgstr ""
"*x* 팩토리얼을 반환합니다. *x*\\가 정수가 아니거나 음수라면 :exc:`ValueError`\\를 "
"발생시킵니다."

#: ../Doc/library/math.rst:59
msgid ""
"Return the floor of *x*, the largest integer less than or equal to *x*. "
"If *x* is not a float, delegates to ``x.__floor__()``, which should "
"return an :class:`~numbers.Integral` value."
msgstr ""
"*x*\\의 천장 함수 값, 즉 *x*\\보다 작거나 같은 최대의 정수값을 반환합니다. *x*\\가"
"실수가 아니라면, :class:`~numbers.Integral` 값을 반환하는 ``x.__floor__()``"
"를 대신 호출합니다."

#: ../Doc/library/math.rst:66
#, python-format
msgid ""
"Return ``fmod(x, y)``, as defined by the platform C library. Note that "
"the Python expression ``x % y`` may not return the same result.  The "
"intent of the C standard is that ``fmod(x, y)`` be exactly "
"(mathematically; to infinite precision) equal to ``x - n*y`` for some "
"integer *n* such that the result has the same sign as *x* and magnitude "
"less than ``abs(y)``.  Python's ``x % y`` returns a result with the sign "
"of *y* instead, and may not be exactly computable for float arguments. "
"For example, ``fmod(-1e-100, 1e100)`` is ``-1e-100``, but the result of "
"Python's ``-1e-100 % 1e100`` is ``1e100-1e-100``, which cannot be "
"represented exactly as a float, and rounds to the surprising ``1e100``.  "
"For this reason, function :func:`fmod` is generally preferred when "
"working with floats, while Python's ``x % y`` is preferred when working "
"with integers."
msgstr ""
"C 라이브러리에서 정의된 ``fmod(x, y)``\\를 반환합니다. 파이썬 구문 ``x % y``\\와 같은 "
"결과를 반환하지 않을 수도 있습니다. C 표준의 ``fmod(x, y)``\\는 ``x - n*y``\\의 결과가 "
"*x*\\와 부호가 같고 절댓값이 ``abs(y)``\\보다 작도록 하는 정수 *n*\\의 정확한(수학적으로; "
"매우 정확하게)반환합니다. 파이썬의 `x % y``\\는 *y*\\와 부호가 같은 값을 반환하며, float "
"매개변수에 대해 정확한 값을 계산하지 못할 수도 있습니다. 예를 들어, ``fmod(-1e-100, 1e100)``"
"은 ``-1e-100`` 이지만, 파이썬의 ``-1e-100 % 1e100`` 은 float으로 정확히 표현될 수 없는 "
"``1e100-1e-100``\\이고, 놀랍게도 이것은 ``1e100``\\으로 반올림됩니다. 이러한 이유로, 함수 "
":func:`fmod`\\는 실수에 대한 연산에서 선호되며, 파이썬의 ``x % y``\\는 정수에 대한 연산에서 "
"선호됩니다."

#: ../Doc/library/math.rst:81
msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a"
" float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* "
"is zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is "
"used to \"pick apart\" the internal representation of a float in a "
"portable way."
msgstr ""
"*x*\\의 가수와 지수를 ``(m, e)`` 쌍으로 반환합니다. *m*\\은 실수이고 *e*\\는 ``x == m * 2**e``"
"를 정확히 만족시키는 정수입니다. 만약 *x*\\가 0이라면, ``(0.0, 0)``\\을 반환하고, 그렇지 않다면 "
"``0.5 <= abs(m) < 1``\\입니다. 이 함수는 실수의 내부 표현을 간단하게 \"얻기 위해\" 사용됩니다."

#: ../Doc/library/math.rst:89
msgid ""
"Return an accurate floating point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums::"
msgstr ""
"이터러블에 있는 값의 정확한 실수 합을 반환합니다. 다양한 중간 부분 합을 추적함으로써 "
"값의 손실을 피합니다::"

#: ../Doc/library/math.rst:97
msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and "
"the typical case where the rounding mode is half-even.  On some non-"
"Windows builds, the underlying C library uses extended precision addition"
" and may occasionally double-round an intermediate sum causing it to be "
"off in its least significant bit."
msgstr ""
"알고리즘의 정확도는 IEEE-754의 연산에 대한 보장과 half-even 반올림 모드에 기반합니다. "
"어떤 비 윈도우 빌드에서, 내재된 C 라이브러리는 연장된 정확도(extended precision) 확장을 "
"사용하며, ~~~을 위해 가끔 중간합을 double-round할 수 있습니다."

#: ../Doc/library/math.rst:103
msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating point summation "
"<https://code.activestate.com/recipes/393090/>`_\\."
msgstr ""
"더 많은 정보와 다른 접근법을 알고 싶다면, `정확한 실수 합에 대한 ASPN "
"문서를 열람하세요 <https://code.activestate.com/recipes/393090/>`_\\."

#: ../Doc/library/math.rst:110
msgid ""
"Return the greatest common divisor of the integers *a* and *b*.  If "
"either *a* or *b* is nonzero, then the value of ``gcd(a, b)`` is the "
"largest positive integer that divides both *a* and *b*.  ``gcd(0, 0)`` "
"returns ``0``."
msgstr ""
"정수 *a*\\와 *b*\\의 최대공약수를 반환합니다. *a* 또는 *b*\\가 0이 아니라면, "
"``gcd(a, b)``\\는 *a*\\와 *b* 모두를 나누는 가장 큰 양의 정수입니다. "
"``gcd(0, 0)``\\는 0을 반환합니다."

#: ../Doc/library/math.rst:120
msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"*a*\\와 *b*\\ 의 값이 서로 가까이 있다면 ``True``\\를, 그렇지 않다면 ``False``"
"를 반환합니다."

#: ../Doc/library/math.rst:123
msgid ""
"Whether or not two values are considered close is determined according to"
" given absolute and relative tolerances."
msgstr ""
"두 값이 가까이 있는지는 주어진 절대 및 상대 오차 한계에 따라 결정됩니다."

#: ../Doc/library/math.rst:126
msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed "
"difference between *a* and *b*, relative to the larger absolute value of "
"*a* or *b*. For example, to set a tolerance of 5%, pass ``rel_tol=0.05``."
"  The default tolerance is ``1e-09``, which assures that the two values "
"are the same within about 9 decimal digits.  *rel_tol* must be greater "
"than zero."
msgstr ""
"*rel_tol*\\은 상대 오차 한계입니다 -- *a*\\와 *b*\\의 절댓값 중 더 큰 값에 따라 결정되는 "
"오차의 최댓값입니다. 예를 들어 오차 한계를 5%로 설정하고자 한다면, ``rel_tol==0.05``"
"를 전달해야 합니다. 오차 한계의 기본값은 ``1e-09``\\이며, 이것은 두 값이 소수점 아래 "
"9자리까지 같다는 것을 보장합니다. *rel_tol*\\은 0보다 커야 합니다."

#: ../Doc/library/math.rst:132
msgid ""
"*abs_tol* is the minimum absolute tolerance -- useful for comparisons "
"near zero. *abs_tol* must be at least zero."
msgstr ""
"*abs_tol* 은 최소 한계 오차입니다 -- 0과 가까운 값의 비교에 유용합니다. *abs_tol*"
"은 0 이상이어야 합니다."

#: ../Doc/library/math.rst:135
msgid ""
"If no errors occur, the result will be: ``abs(a-b) <= max(rel_tol * "
"max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"에러가 발생하지 않은 경우, 결과는 다음과 같을 것입니다: ``abs(a-b) <= max(rel_tol * "
"max(abs(a), abs(b)), abs_tol)``."

#: ../Doc/library/math.rst:138
msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered"
" close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are "
"only considered close to themselves."
msgstr ""
"IEEE 754의 특수 값인 ``NaN``\\, ``inf``\\, ``-inf``\\은 IEEE 규칙에 의해 "
"처리됩니다. 구체적으로 ``NaN``은 자기 자신을 포함한 다른 어떤 값과도 가깝지 않으며, "
"``inf``\\와 ``-inf``\\은 자기 자신만이 가까운 값으로 판정됩니다."

#: ../Doc/library/math.rst:147
msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ""
"":pep:`485` -- 동등함을 대략적으로 확인하는 함수"

#: ../Doc/library/math.rst:152
msgid ""
"Return ``True`` if *x* is neither an infinity nor a NaN, and ``False`` "
"otherwise.  (Note that ``0.0`` *is* considered finite.)"
msgstr ""
"*x*\\가 무한 또는 NaN이 아니라면 ``True``\\를, 그렇지 않다면 ``False``\\를 "
"반환합니다. (``0.0``\\은 유한입니다.)

#: ../Doc/library/math.rst:160
msgid ""
"Return ``True`` if *x* is a positive or negative infinity, and ``False`` "
"otherwise."
msgstr ""
""*x*\\가 양 또는 음의 무한이라면 ``True``\\를, 그렇지 않다면 ``False``\\를 "
"반환합니다."

#: ../Doc/library/math.rst:166
msgid "Return ``True`` if *x* is a NaN (not a number), and ``False`` otherwise."
msgstr ""
"*x*\\가 NaN(숫자가 아님)이라면 ``True``\\를, 그렇지 않다면 ``False``\\를 "
"반환합니다."

#: ../Doc/library/math.rst:171
msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function "
":func:`frexp`."
msgstr ""
""``x * (2**i)``\\를 반환합니다. 이것은 본질적으로 함수 :func:`frexp`\\의 역입니다."

#: ../Doc/library/math.rst:177
msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the "
"sign of *x* and are floats."
msgstr ""
"*x*\\의 정수 부분과 소수 부분을 반환합니다. 각 값은 실수이며, *x*\\의 부호를 따릅니다."

#: ../Doc/library/math.rst:183
msgid ""
"Return the IEEE 754-style remainder of *x* with respect to *y*.  For "
"finite *x* and finite nonzero *y*, this is the difference ``x - n*y``, "
"where ``n`` is the closest integer to the exact value of the quotient ``x"
" / y``.  If ``x / y`` is exactly halfway between two consecutive "
"integers, the nearest *even* integer is used for ``n``.  The remainder "
"``r = remainder(x, y)`` thus always satisfies ``abs(r) <= 0.5 * abs(y)``."
msgstr ""
"*y*\\에 대한 *x*\\의 IEEE-754 스타일의 나머지를 반환합니다. 유한 값 *x*\\와 "
"0이 아닌 유한 값 *y*\\에 대해, 이것은 ``x - n*y``\\와 같습니다. 이때 ``n``\\은 "
"``x / y``\\의 정확한 값과 가장 가까운 정수입니다. ``x / y``\\가 연속되는 두 정수의 "
"중점에 있을 때, 가장 가까운 *짝수* 값이 ``n``\\으로 쓰입니다. 따라서 나머지 ``r = "
"remainder(x, y)``\\는 항상 ``abs(r) <= 0.5 * abs(y)``\\를 만족시킵니다.""

#: ../Doc/library/math.rst:190
msgid ""
"Special cases follow IEEE 754: in particular, ``remainder(x, math.inf)`` "
"is *x* for any finite *x*, and ``remainder(x, 0)`` and "
"``remainder(math.inf, x)`` raise :exc:`ValueError` for any non-NaN *x*. "
"If the result of the remainder operation is zero, that zero will have the"
" same sign as *x*."
msgstr ""
"특이 케이스의 경우 IEEE 754를 따릅니다: 특히 ``remainder(x, math.inf)``\\는 "
"모든 유한한 *x*\\에 대해 *x*\\이고, ``remainder(x, 0)``\\과 "
"``remainder(math.inf, x)``\\는 NaN이 아닌 모든 *x*\\에 대해 :exc:`ValueError`"
"를 발생시킵니다. 나머지 연산의 결과가 0이라면, 이 0은 *x*\\와 같은 부호를 가집니다."

#: ../Doc/library/math.rst:196
msgid ""
"On platforms using IEEE 754 binary floating-point, the result of this "
"operation is always exactly representable: no rounding error is "
"introduced."
msgstr ""
"IEEE 754 이진 부동 소수점을 사용하는 플랫폼에서, 이 연산의 결과는 항상 표현 가능합니다: "
"반올림 에러는 발생하지 않습니다."

#: ../Doc/library/math.rst:204
msgid ""
"Return the :class:`~numbers.Real` value *x* truncated to an "
":class:`~numbers.Integral` (usually an integer). Delegates to "
":meth:`x.__trunc__() <object.__trunc__>`."
msgstr ""
"

#: ../Doc/library/math.rst:209
msgid ""
"Note that :func:`frexp` and :func:`modf` have a different call/return "
"pattern than their C equivalents: they take a single argument and return "
"a pair of values, rather than returning their second return value through"
" an 'output parameter' (there is no such thing in Python)."
msgstr ""

#: ../Doc/library/math.rst:214
msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note "
"that *all* floating-point numbers of sufficiently large magnitude are "
"exact integers. Python floats typically carry no more than 53 bits of "
"precision (the same as the platform C double type), in which case any "
"float *x* with ``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ""

#: ../Doc/library/math.rst:222
msgid "Power and logarithmic functions"
msgstr ""

#: ../Doc/library/math.rst:226
msgid ""
"Return *e* raised to the power *x*, where *e* = 2.718281... is the base "
"of natural logarithms.  This is usually more accurate than ``math.e ** "
"x`` or ``pow(math.e, x)``."
msgstr ""

#: ../Doc/library/math.rst:233
msgid ""
"Return *e* raised to the power *x*, minus 1.  Here *e* is the base of "
"natural logarithms.  For small floats *x*, the subtraction in ``exp(x) - "
"1`` can result in a `significant loss of precision "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\; the "
":func:`expm1` function provides a way to compute this quantity to full "
"precision::"
msgstr ""

#: ../Doc/library/math.rst:250
msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr ""

#: ../Doc/library/math.rst:252
msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr ""

#: ../Doc/library/math.rst:258
msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is "
"calculated in a way which is accurate for *x* near zero."
msgstr ""

#: ../Doc/library/math.rst:264
msgid ""
"Return the base-2 logarithm of *x*. This is usually more accurate than "
"``log(x, 2)``."
msgstr ""

#: ../Doc/library/math.rst:271
msgid ""
":meth:`int.bit_length` returns the number of bits necessary to represent "
"an integer in binary, excluding the sign and leading zeros."
msgstr ""

#: ../Doc/library/math.rst:277
msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr ""

#: ../Doc/library/math.rst:283
msgid ""
"Return ``x`` raised to the power ``y``.  Exceptional cases follow Annex "
"'F' of the C99 standard as far as possible.  In particular, ``pow(1.0, "
"x)`` and ``pow(x, 0.0)`` always return ``1.0``, even when ``x`` is a zero"
" or a NaN.  If both ``x`` and ``y`` are finite, ``x`` is negative, and "
"``y`` is not an integer then ``pow(x, y)`` is undefined, and raises "
":exc:`ValueError`."
msgstr ""

#: ../Doc/library/math.rst:290
msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow`"
" function for computing exact integer powers."
msgstr ""

#: ../Doc/library/math.rst:297
msgid "Return the square root of *x*."
msgstr ""

#: ../Doc/library/math.rst:301
msgid "Trigonometric functions"
msgstr ""

#: ../Doc/library/math.rst:305
msgid "Return the arc cosine of *x*, in radians."
msgstr ""

#: ../Doc/library/math.rst:310
msgid "Return the arc sine of *x*, in radians."
msgstr ""

#: ../Doc/library/math.rst:315
msgid "Return the arc tangent of *x*, in radians."
msgstr ""

#: ../Doc/library/math.rst:320
msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes"
" this angle with the positive X axis. The point of :func:`atan2` is that "
"the signs of both inputs are known to it, so it can compute the correct "
"quadrant for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are "
"both ``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr ""

#: ../Doc/library/math.rst:330
msgid "Return the cosine of *x* radians."
msgstr ""

#: ../Doc/library/math.rst:335
msgid ""
"Return the Euclidean norm, ``sqrt(x*x + y*y)``. This is the length of the"
" vector from the origin to point ``(x, y)``."
msgstr ""

#: ../Doc/library/math.rst:341
msgid "Return the sine of *x* radians."
msgstr ""

#: ../Doc/library/math.rst:346
msgid "Return the tangent of *x* radians."
msgstr ""

#: ../Doc/library/math.rst:350
msgid "Angular conversion"
msgstr ""

#: ../Doc/library/math.rst:354
msgid "Convert angle *x* from radians to degrees."
msgstr ""

#: ../Doc/library/math.rst:359
msgid "Convert angle *x* from degrees to radians."
msgstr ""

#: ../Doc/library/math.rst:363
msgid "Hyperbolic functions"
msgstr ""

#: ../Doc/library/math.rst:365
msgid ""
"`Hyperbolic functions "
"<https://en.wikipedia.org/wiki/Hyperbolic_function>`_ are analogs of "
"trigonometric functions that are based on hyperbolas instead of circles."
msgstr ""

#: ../Doc/library/math.rst:371
msgid "Return the inverse hyperbolic cosine of *x*."
msgstr ""

#: ../Doc/library/math.rst:376
msgid "Return the inverse hyperbolic sine of *x*."
msgstr ""

#: ../Doc/library/math.rst:381
msgid "Return the inverse hyperbolic tangent of *x*."
msgstr ""

#: ../Doc/library/math.rst:386
msgid "Return the hyperbolic cosine of *x*."
msgstr ""

#: ../Doc/library/math.rst:391
msgid "Return the hyperbolic sine of *x*."
msgstr ""

#: ../Doc/library/math.rst:396
msgid "Return the hyperbolic tangent of *x*."
msgstr ""

#: ../Doc/library/math.rst:400
msgid "Special functions"
msgstr ""

#: ../Doc/library/math.rst:404
msgid ""
"Return the `error function "
"<https://en.wikipedia.org/wiki/Error_function>`_ at *x*."
msgstr ""

#: ../Doc/library/math.rst:407
msgid ""
"The :func:`erf` function can be used to compute traditional statistical "
"functions such as the `cumulative standard normal distribution "
"<https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function>`_::"
msgstr ""

#: ../Doc/library/math.rst:420
msgid ""
"Return the complementary error function at *x*.  The `complementary error"
" function <https://en.wikipedia.org/wiki/Error_function>`_ is defined as "
"``1.0 - erf(x)``.  It is used for large values of *x* where a subtraction"
" from one would cause a `loss of significance "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\."
msgstr ""

#: ../Doc/library/math.rst:431
msgid ""
"Return the `Gamma function "
"<https://en.wikipedia.org/wiki/Gamma_function>`_ at *x*."
msgstr ""

#: ../Doc/library/math.rst:439
msgid ""
"Return the natural logarithm of the absolute value of the Gamma function "
"at *x*."
msgstr ""

#: ../Doc/library/math.rst:446
msgid "Constants"
msgstr ""

#: ../Doc/library/math.rst:450
msgid "The mathematical constant *π* = 3.141592..., to available precision."
msgstr ""

#: ../Doc/library/math.rst:455
msgid "The mathematical constant *e* = 2.718281..., to available precision."
msgstr ""

#: ../Doc/library/math.rst:460
msgid ""
"The mathematical constant *τ* = 6.283185..., to available precision. Tau "
"is a circle constant equal to 2\\ *π*, the ratio of a circle's "
"circumference to its radius. To learn more about Tau, check out Vi Hart's"
" video `Pi is (still) Wrong "
"<https://www.youtube.com/watch?v=jG7vhMMXagQ>`_, and start celebrating "
"`Tau day <https://tauday.com/>`_ by eating twice as much pie!"
msgstr ""

#: ../Doc/library/math.rst:471
msgid ""
"A floating-point positive infinity.  (For negative infinity, use "
"``-math.inf``.)  Equivalent to the output of ``float('inf')``."
msgstr ""

#: ../Doc/library/math.rst:479
msgid ""
"A floating-point \"not a number\" (NaN) value.  Equivalent to the output "
"of ``float('nan')``."
msgstr ""

#: ../Doc/library/math.rst:487
msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the "
"platform C math library functions.  Behavior in exceptional cases follows"
" Annex F of the C99 standard where appropriate.  The current "
"implementation will raise :exc:`ValueError` for invalid operations like "
"``sqrt(-1.0)`` or ``log(0.0)`` (where C99 Annex F recommends signaling "
"invalid operation or divide-by-zero), and :exc:`OverflowError` for "
"results that overflow (for example, ``exp(1000.0)``).  A NaN will not be "
"returned from any of the functions above unless one or more of the input "
"arguments was a NaN; in that case, most functions will return a NaN, but "
"(again following C99 Annex F) there are some exceptions to this rule, for"
" example ``pow(float('nan'), 0.0)`` or ``hypot(float('nan'), "
"float('inf'))``."
msgstr ""

#: ../Doc/library/math.rst:499
msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet"
" NaNs, and behavior for signaling NaNs remains unspecified. Typical "
"behavior is to treat all NaNs as though they were quiet."
msgstr ""

#: ../Doc/library/math.rst:506
msgid "Module :mod:`cmath`"
msgstr ""

#: ../Doc/library/math.rst:507
msgid "Complex number versions of many of these functions."
msgstr ""

#~ msgid ""
#~ "Return the :class:`~numbers.Real` value *x*"
#~ " truncated to an :class:`~numbers.Integral` "
#~ "(usually an integer). Delegates to "
#~ "``x.__trunc__()``."
#~ msgstr ""

#~ msgid "Return ``e**x``."
#~ msgstr ""

#~ msgid ""
#~ "Return ``e**x - 1``.  For small "
#~ "floats *x*, the subtraction in ``exp(x)"
#~ " - 1`` can result in a "
#~ "`significant loss of precision "
#~ "<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\; the"
#~ " :func:`expm1` function provides a way "
#~ "to compute this quantity to full "
#~ "precision::"
#~ msgstr ""

#~ msgid "The mathematical constant π = 3.141592..., to available precision."
#~ msgstr ""

#~ msgid "The mathematical constant e = 2.718281..., to available precision."
#~ msgstr ""

#~ msgid ""
#~ "The mathematical constant τ = "
#~ "6.283185..., to available precision. Tau "
#~ "is a circle constant equal to 2π,"
#~ " the ratio of a circle's "
#~ "circumference to its radius. To learn"
#~ " more about Tau, check out Vi "
#~ "Hart's video `Pi is (still) Wrong "
#~ "<https://www.youtube.com/watch?v=jG7vhMMXagQ>`_, and start"
#~ " celebrating `Tau day <http://tauday.com/>`_ "
#~ "by eating twice as much pie!"
#~ msgstr ""

